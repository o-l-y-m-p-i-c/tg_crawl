# import asyncio
# import datetime
# import json
# import math
# import random
# import threading
# from time import sleep
# from telethon.tl import functions, types

# import numpy as np
# from telethon.errors import ChannelPrivateError, rpcerrorlist
# from telethon.sync import TelegramClient
# from telethon.tl.functions.messages import GetHistoryRequest


# def get_history(ch, dt):
#     return GetHistoryRequest(
#         peer=ch,
#         offset_id=0,
#         offset_date=dt,
#         add_offset=0,
#         limit=100,
#         max_id=0,
#         min_id=0,
#         hash=0
#     )


# def color_gradient(x):
#     return 255 * x, 0, 255 - 255 * x


# def hsv_to_rgb(h, s, v):
#     h_i = int(h * 6)
#     f = h * 6 - h_i
#     p = v * (1 - s)
#     q = v * (1 - f * s)
#     t = v * (1 - (1 - f) * s)
#     if h_i == 0:
#         r, g, b = v, t, p
#     elif h_i == 1:
#         r, g, b = q, v, p
#     elif h_i == 2:
#         r, g, b = p, v, t
#     elif h_i == 3:
#         r, g, b = p, q, v
#     elif h_i == 4:
#         r, g, b = t, p, v
#     elif h_i == 5:
#         r, g, b = v, p, q
#     else:
#         r, g, b = 0, 0, 0
#     return int(r * 256), int(g * 256), int(b * 256)


# class TGScanner(threading.Thread):
#     # 22222967
#     # 27426964
#     api_id = 27426964
#     # fe6a3f18e0ceb89afd2527b7ff0f1c47
#     # dd1ee07cbf165e7bdd64d85361f7b209
#     api_hash = 'dd1ee07cbf165e7bdd64d85361f7b209'

#     # start_channel = "t.me/disclosetv"
#     # start_channel = "t.me/Rare_Pepe_Coin_News"
#     # @CoingraphNews

#     max_depth = 4
#     from_date = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(hours=1008)

#     golden_ratio_conjugate = 0.618033988749895
#     h = random.randint(0, 256)

#     def __init__(self):
#         super().__init__()
#         self.update = None
#         self.add_node_list = None
#         self.remove_node_list = None
#         self.set_text = None

#     def next_color(self):
#         self.h += self.golden_ratio_conjugate
#         self.h %= 1
#         return hsv_to_rgb(self.h, .5, .95)

#     async def fetch_channel(self, client, channel_username):
#         try:
#             return await client.get_entity(channel_username)
#         except ChannelPrivateError:
#             print(f"Cannot access channel: {channel_username}")
#         except Exception as e:
#             print(f"Error fetching channel {channel_username}: {e}")

#     async def scan(self, channel_list):
#         async with TelegramClient('anon', self.api_id, self.api_hash) as client:

#             self.set_text({'id': 'date-time', 'text': self.from_date.strftime("%d-%m-%Y %H:%M:%S")})
#             self.set_text({'id': 'depth', 'text': self.max_depth})

#             channels_usernames = [
#                 "t.me/CoingraphNews",
#                 "t.me/PEPE2024_Coin_News", #PEPE
#                 "t.me/Rare_Pepe_Coin_News",
#                 "t.me/brettcoin_en", #BRET
#                 "t.me/brettcointoon",
#                 "t.me/andycoinbsc_en", # ANDY
#                 "t.me/TheOnlyAndyLeft_Coin",
#                 # "t.me/andy_coinbsc",

#                 "t.me/landwolf_token_eng", #LANDWOLF
#                 "t.me/LANDWOLFSOLL",
#                 "t.me/TurboBotNewTokenDeploy", #Turbo
#                 "t.me/TurboToadToken",
#                 "t.me/TurboToad_Token_Network",
#                 "t.me/myroSOL", #dddddd
#                 "t.me/BabyMyro_Token1",

#                 "t.me/HOPPY_English", #HOPPY
#                 "t.me/HOPPYTokenAnnouncements",
#                 "t.me/HoppyCommunityz", 
#                 "t.me/HoppyTokenChat",
#                 "t.me/dogwifhatl", #wif
#                 "t.me/Dogwifhats_Chat", 
#                 "t.me/dogwifhat0",

#                 "t.me/manekinekotokenio", #MANEKI
#                 "t.me/maneki_official",
#                 "t.me/foxy_ton_token", #foxy
#                 "t.me/MAGAA_tokens", #maga
#                 "t.me/maganomics_token", 
#                 "t.me/LFGO_TELEGRAM", 
#                 "t.me/LFGOfficialCommunity/90998",
#                 "t.me/polariumtoken",
#             ]

#             channels = channel_list
#             # for username in channels_usernames:
#             #     ch = await self.fetch_channel(client, username)
#             #     if ch:
#             #         channels.append(ch)

#             # for channel in channel_list:
#             #     channels.append(channel)

#             start_channel = await client.get_entity(channels[0])
#             channels.append(start_channel)

#             channels_dict = {}
#             channels_dict[start_channel.id] = {
#                 'out': [],
#                 'in': [],
#                 'msg_count': -1,
#                 'users': {},
#                 'title': start_channel.title,
#                 'depth': 0,
#                 'color': '#000000'
#             }

#             c_max = 10
#             channel_idx = 0
#             date_time = datetime.datetime.now(datetime.timezone.utc)
#             curr_channel = start_channel

#             print("Starting channels:")
#             for ch_ in channels:
#                 print(ch_.title if hasattr(ch_, 'title') else ch_.first_name)
#                 self.update({
#                     'nodes': [{
#                         'id': ch_.id,
#                         'label': ch_.title,
#                         'size': 10,
#                         'color': {
#                             'border': '#ff0000'
#                         }
#                     }],
#                     'edges': []
#                 })
#                 self.add_node_list({'label': ch_.title})
#             print("")
#             print("New channel: " + (curr_channel.title if hasattr(curr_channel, 'title') else curr_channel.first_name))

#             while True:
#                 hist = (await asyncio.gather(client(get_history(curr_channel, date_time))))[0]

#                 if curr_channel.id not in channels_dict:
#                     channels_dict[curr_channel.id] = {
#                         'out': [],
#                         'in': [],
#                         'msg_count': -1,
#                         'users': {},
#                         'title': curr_channel.title,
#                         'depth': 0,
#                         'color': '#000000'
#                     }

#                 channels_dict[curr_channel.id]['msg_count'] = hist.count

#                 for user in hist.users:
#                     channels_dict[curr_channel.id]['users'][user.id] = user.first_name

#                 for msg in hist.messages:
#                     if msg.date < self.from_date:
#                         date_time = msg.date
#                         break
#                     if msg.fwd_from and hasattr(msg.fwd_from.from_id, 'channel_id'):
#                         try:
#                             ch_ = (await asyncio.gather(client.get_entity(msg.fwd_from.from_id)))[0]
#                         except ChannelPrivateError:
#                             continue

#                         if channels_dict[curr_channel.id]['depth'] < self.max_depth and ch_ not in channels:
#                             channels.append(ch_)
#                             print("New channel found: " + ch_.title)
#                             self.add_node_list({'label': ch_.title})

#                         if ch_.id not in channels_dict.keys():
#                             channels_dict[ch_.id] = {
#                                 'out': [curr_channel.id],
#                                 'in': [],
#                                 'msg_count': -1,
#                                 'users': {},
#                                 'title': ch_.title,
#                                 'depth': channels_dict[curr_channel.id]['depth'] + 1,
#                                 'color': '#000000'
#                             }
#                         else:
#                             if channels_dict[ch_.id]['depth'] > channels_dict[curr_channel.id]['depth'] + 1:
#                                 channels_dict[ch_.id]['depth'] = channels_dict[curr_channel.id]['depth'] + 1
#                             channels_dict[ch_.id]['out'].append(curr_channel.id)

#                         channels_dict[curr_channel.id]['in'].append(ch_.id)

#                         c = len(channels_dict[ch_.id]['out'])

#                         if c > 1 and channels_dict[curr_channel.id]['color'] == '#000000':
#                             channels_dict[curr_channel.id]['color'] = "#%02x%02x%02x" % self.next_color()

#                         data = {
#                             'nodes': [{
#                                 'id': ch_.id,
#                                 'label': ch_.title,
#                                 'size': math.pow(len(channels_dict[ch_.id]['out']), 1 / 1.9) + 10
#                             }],
#                             'edges': [{
#                                 'id': '{}{}'.format(curr_channel.id, ch_.id),
#                                 'from': ch_.id,
#                                 'to': curr_channel.id,
#                                 'color': channels_dict[ch_.id]['color']
#                                 if c > len(channels_dict[curr_channel.id]['out'])
#                                 else channels_dict[curr_channel.id]['color']
#                             }]
#                         }

#                         self.update(data)

#                 if len(hist.messages) < 100 or date_time < self.from_date:
#                     channel_idx += 1
#                     self.remove_node_list()

#                     if channel_idx >= len(channels):
#                         self.update({
#                             'nodes': [
#                                 {
#                                     'id': curr_channel.id,
#                                     'color': {
#                                         'border': '#0000ff'
#                                     }
#                                 }]
#                         })
#                         break

#                     self.update({
#                         'nodes': [
#                             {
#                                 'id': curr_channel.id,
#                                 'color': {
#                                     'border': '#0000ff'
#                                 }
#                             },
#                             {
#                                 'id': channels[channel_idx].id,
#                                 'color': {
#                                     'border': '#ff0000'
#                                 }
#                             }]
#                     })
#                     date_time = datetime.datetime.now(datetime.timezone.utc)
#                     curr_channel = channels[channel_idx]
#                     print("")
#                     print("New channel: " + (curr_channel.title if hasattr(curr_channel, 'title') else curr_channel.first_name))
#                 else:
#                     date_time = hist.messages[-1].date
    
#     async def getChannels(self, keyword):
#         async with TelegramClient('anon', self.api_id, self.api_hash) as client:
#             result = await client(functions.contacts.SearchRequest(
#                 q=keyword,
#                 limit=2
#             ))

#             channel_list = list()

#             for channel in result.chats:
#                 # print(channel)
#                 channel_list.append(channel)
            
#             return channel_list

#     def run(self):

#         flag = True
#         num = 0

#         keywords = [
#             '$PEPE',
#             '$BRETT',
#             '$ANDY',
#             '$LANDWOLF',
#             '$TURBO',
#             '$MYRO',
#             '$HOPPY',
#             '$WIF',
#             '$MANEKI',
#             '$FOXY',
#             '$MAGA',
#             '$LFGO',
#             '$POLA',
#         ]

#         channel_list = list()
#         for keyword in keywords:
#             keyword_list = asyncio.run(self.getChannels(keyword))
#             channel_list = channel_list + keyword_list
        

#         while True:
#             sleep(1)
#             try:
#                 asyncio.run(self.scan(channel_list))
#             except (rpcerrorlist.PhoneNumberInvalidError, rpcerrorlist.AccessTokenInvalidError) as e:
#                 print(e.message)
#                 pass
                
